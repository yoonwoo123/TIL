## 이미지 레이지 로딩

### lazy loading의 구현 방식에는 여러 가지가 있다.

- 레이지 로딩이란 이미지에 대한 로딩을 뒤로 미루는 것을 의미합니다.

  - **레이지로딩을 구현하지 않은 웹페이지를 열면 브라우저가 모든 이미지를 읽고 불러와서 DOM에 렌더링 할것입니다.** 이미지가 많지 않으면 상관이 없지만 정말 많은 이미지가 한 페이지에 있다면 그 페이지를 여는 시간도 오래 걸릴 것이고 만약 모바일 데이터를 이용하여 웹페이지에 접속중이라면 데이터도 많이 들고 만약 실수로 들어왔거나 이미지를 맨 위에 두 어개 정도만 보고 나간다면 이 모든 **리소스가 낭비**됩니다. 따라서 우리는 **어떤 이미지를 로딩할 필요가 있으면 그 때 이미지를 불러올 것**이고 일반적으로 레이지 로딩은 **스크롤 애니메이션을 통해 구현**됩니다.

  - 방법1

    모든 이미지를 querySelectorAll로 가져온 후 이미지마다 스크롤 이벤트를 걸어서 img.getBoundingClientRect().top 보다 window.innerHeight가 크다면 (이미지가 보일 타이밍을 계산) img 태그의 data-lazy에 저장해둔 이미지 경로를 붙여주고 추가적으로 classList.add를 통해서 보여주고 싶은 애니메이션(트랜지션)을 넣어준다.

    

    단점: 이벤트 리스너를 스크롤에 주는 굉장히 리소스 낭비가 심한 방법이며 심지어 모든 이미지가 로딩이 끝나고 계속해서 이미지의 위치를 계산하게 됩니다.

    장점: 방법2에서 사용할 IntersectionObserver API가 지원되지 않는 구형 브라우저에서는 이러한 방법을 사용해서 구현해야 할 것입니다.

    

  - 방법2

    IntersectionObserver 라는 API를 사용하여 더 효율적으로 구현할 수 있습니다. io는 어떤 엘리먼트가 화면에 노출되었는지를 알려줍니다.

    io.observe(target)으로 타겟을 관찰해주면서,

    io의 첫번째 인자 (entries)는 들어오는 타겟 엘리먼트들로써 엔트리(이미지 1개)마다

    isIntersecting을 통해 반환된 boolean 값으로 현재 화면에 타겟이 들어왔는지 아닌지를 판단합니다. 만약 들어왔다면 타겟의 data-lazy 값을 읽어서 src를 setAttribute 해주고 classList.add()로 원하는 클래스를 넣어서 애니메이션 효과를 주고 observer.disconnect로 observer의 관찰을 중지시켜 불필요한 리소스를 막습니다.

    이렇게 하여 이미지 로딩은 단 한번만 하게 되고 타겟 이미지의 로딩이 완료되면 더 이상 observer가 화면을 지켜보고 있지 않게 되어 불필요한 리소스 낭비를 막게 되었습니다.

    

  - 레이지 로딩을 적용할 때 주의해야할 사항

    이미지 및 비디오를 lazy loading 하는 것은 성능 이점을 가져올 수 있지만, 잘못 이해한다면 의도하지 않은 결과를 발생시킬 수 있습니다.

    1. 폴드를 기억하라.

       (폴드: 스크롤 없이 볼 수 있는 영역)

       폴드에 있는 미디어 리소스들은 lazy 로딩이 되어서는 안됩니다.

       평범한 일반적인 방식으로 로드되어야 합니다. 왜냐하면 lazy loading 스크립트가 로딩을 완료하고 실행을 시작하여 DOM이 반응하기 전까지 중요한 자원 리소스(폴드에 있는 리소스)들의 lazy loading을 지연시키기 때문입니다. 물론 웹사이트들이 다양한 크기의 스크린에서 보여지고 있는 요즘은 폴드 영역이 어디에 놓여 있는지 명확하지 않습니다. 모든 상황에서 이 문제를 최적으로 해결하기 위한 최고의 해결책은 없습니다. 따라서 페이지의 중요 리소스들을 따로 관리하여 일방적인 방식으로 로드해야 합니다.

       또한 lazy load를 발생시키는 폴드 영역의 기준선은 너무 엄격하지 않아도 됩니다. 사용자가 해당 리소스가 있는 부분으로 스크롤하기 전에 이미지가 잘 로드될 수 있도록 폴드 영역 아래로 일정 거리의 버퍼 영역을 설정하는 것이 좋습니다. IntersectionObserver 인스턴스를 만들 때 옵션 객체에서 rootMargin속성을 지정할 수 있습니다. 이건 효과적으로 엘리먼트에게 버퍼를 주며, 엘리먼트가 화면에 표시되기 전에 lazy 로딩 동작을 수행합니다.

    2. 레이아웃 및 placeholder

       레이지 로딩 미디어는 플레이스홀더를 사용하지 않을 경우 레이아웃을 변경시킬 수 있습니다. 이러한 변화는 사용자를 혼란스럽게 할 수 있으며 시스템 리소스를 소비하고 값 비싼 DOM 레이아웃 작업을 유발할 수 있습니다. 최소한 대상 이미지와 동일한 크기를 차지하는 단색 placeholder나 로드하기 전에 미디어 항목의 내용을 암시하는 LQIP 또는 SQIP와 같은 기술을 사용하는 것이 좋습니다.

       img 태그에선 src 속성이 최종 이미지의 URL로 업데이트 될 때까지 태그의 위치가 변경되면 안됩니다. 이렇게 하면 미디어가 로드될때 placeholder에서 최종 이미지로 전환해도 엘리먼트의 크기가 변경되지 않습니다.

    3. 이미지 디코딩 지연

       JS에서 큰 이미지를 로딩하여 DOM에 놓으면 기본 스레드가 잠기기 때문에, 디코딩이 발생하는 동안 사용자가 짧은 시간동안 응답하지 않게 됩니다. DOM에 삽입하기 전에 디코드 메서드를 이용한 비동기 이미지 디코딩을 사용하면 이러한 문제를 해결할 수 있습니다.(하지만 아직 모든 브라우저 지원x) 큰 이미지를 지연 로딩하여 DOM에 삽입할 때 분명 효과가 있습니다.

    4. 로드가 되지 않았을 때 (무슨 말인지 잘 모르겠다..)

    5. 자바스크립트의 사용 가능성

       자바스크립트를 항상 사용할 수 있다고 가정해서는 안 됩니다.

       자스를 사용할 수 없는 경우 noscript 태그를 고려할 수 있습니다.


  

  ### 추가적으로 CDN에 대해서 학습

  - CDN이란?

    컨텐츠 딜리버리 네트워크의 약자로써

    - 지리 물리적으로 떨어져 있는 사용자에게 컨텐츠를 더 빠르게 제공할 수 있는 기술
    - 느린 응답속도, 다운로딩 타임을 극복하기 위한 기술

    사용되어지는 예

    - 온라인게임의 OBT시 클라이언트 다운로드를 CDN으로 분산

      뿐만 아니라 대규모 업데이트 시에도 콘텐츠 병목 현상이 일어날 수 있어 CDN 사용

    - 물리적으로 거리가 떨어진 경우 예를 들어 내 홈페이지가 한국에 있고 서버도 한국에 있다고 치면 미국에서 접속한 사용자가 사이트에 접속했을 때 한국에 있는 서버를 이용해 이미지를 호출 할 것이다. 

      이를 보완하기 위해 이용자가 요청했을 때 제일 근접한 서버에서 처리함으로써 지연되는 시간을 줄여주고 이 과정에서 여러곳에 캐시서버를 분산해서 한 개의 서버가 뻗더라도 다른 서버에서 이미지를 제공할 수 있다.

      

    - 요약하자면 사용자가 원격지에 있는 서버로 부터 컨텐츠를 다운로드 받을 때 가까이 있는 서버에서 받는 것보다 시간이 오래 걸린다.

      그러므로 사용자와 가까운 곳에 위치한 캐시 서버에 해당 컨텐츠를 저장(캐싱)하고 컨텐츠 요청 시에 캐시 서버가 응답을 주는 기술이다.

      

    - CDN의 작동원리

      1. 최초 요청은 서버로부터 컨텐츠를 가져와 고객에게 전송하며 동시에 CDN캐싱장비에 저장한다.
      2. 두 번째 이후 모든 요청은 CDN 업체에서 지정하는 해당 컨텐츠 만료 시점까지 CDN 캐싱장비에 저장된 컨텐츠를 전송한다.
      3. 자주 사용하는 페이지에 한해서 CDN장비에서 캐싱이 되며, 해당 컨텐츠 호출이 없을 경우 주기적으로 삭제한다.
      4. 서버가 파일을 찾는 데 실패하는 경우 CDN 플랫폼의 다른 서버에서 콘텐츠를 찾아 엔드유저에게 응답을 전송한다.
      5. 콘텐츠를 사용할 수 없거나 콘텐츠가 오래된 경우, CDN은 서버에 대한 요청을 프록시로 작동하여 향후 요청에 대해 응답할 수 있도록 새로운 콘텐츠를 저장한다.

    - CDN의 필요기술

      1. Load Balance

         사용자에게 콘텐츠 전송 요청을 받았을 때, 최적의 네트워크 환경을 찾아 연결하는 기술, GSLB (Global Server Load Balancing) 이라고도한다. 물리적으로 가장 가깝거나 여유 트래픽이 남아 있는 곳으로 접속을 유도하는 기술이다.

         DNS와 GSLB의 차이점은 DNS는 라운드 로빈으로 작동하여

         (라운드로빈: 선점형 스케줄링 중 하나로써 프로세스들 사이에서 우선순위를 두지 않고, 순서대로 시간 단위로 CPU를 할당하는 방식의 CPU 스케줄링 알고리즘이다.)

         항상 가까운 지역이 아닌 멀리 떨어진 위치의 서버로도 연결될 수 있으나 GSLB는 최적화되어져서 실행된다.

      2. 컨텐츠를 배포하는 기술

         컨텐츠의 삭제나 수정이 일어났을 때 이를 관리할 수 있는 기술이 필요하다.

      3. CDN의 트래픽을 감지하는 기술

         통계자료를 고객에게 제공하기 위해 필요하다

         트래픽을 분산하기 위해 필요하다.

    - WEB-CACHE 

      캐쉬를 컨트롤하기 위해서 HTTP Headers를 사용하여

      파일이 이전과 비교하여 변경 되었는가를 체크하는 validation과 캐쉬의 만료 여부를 체크하는 freshness 로 구성되어 있습니다.

      ​						HTTP 1.0 / HTTP 1.1

      validation : Last-Modified, Etag (우선순위 더 높음)

      freshness: Expires, Cache-Control (우선순위 더 높음)

